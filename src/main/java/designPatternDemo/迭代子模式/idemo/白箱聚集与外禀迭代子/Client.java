package designPatternDemo.迭代子模式.idemo.白箱聚集与外禀迭代子;

public class Client {
	

	
	
	/**
	 * 迭代子模式的结构
　　迭代子模式有两种实现方式，分别是白箱聚集与外禀迭代子和黑箱聚集于内禀迭代子。

白箱聚集与外禀迭代子
　　如果一个聚集的接口提供了可以用来修改聚集元素的方法，这个接口就是所谓的宽接口。

　　如果聚集对象为所有对象提供同一个接口，也就是宽接口的话，当然会满足迭代子模式对迭代子对象的要求。但是，这样会破坏对聚集对象的封装。这种提供宽接口的聚集叫做白箱聚集。聚集对象向外界提供同样的宽接口，如下图所示：
	 * 
	 * 
	 * 
	 * 由于聚集自己实现迭代逻辑，并向外部提供适当的接口，使得迭代子可以从外部控制聚集元素的迭代过程。这样一来迭代子所控制的仅仅是一个游标而已，这种迭代子叫做游标迭代子（Cursor Iterator）。由于迭代子是在聚集结构之外的，因此这样的迭代子又叫做外禀迭代子（Extrinsic Iterator）。

　　现在看一看白箱聚集与外禀迭代子的实现。一个白箱聚集向外界提供访问自己内部元素的接口（称作遍历方法或者Traversing Method），从而使外禀迭代子可以通过聚集的遍历方法实现迭代功能。

　　因为迭代的逻辑是由聚集对象本身提供的，所以这样的外禀迭代子角色往往仅仅保持迭代的游标位置。

　　一个典型的由白箱聚集与外禀迭代子组成的系统如下图所示，在这个实现中具体迭代子角色是一个外部类，而具体聚集角色向外界提供遍历聚集元素的接口。
	 * 
	 * 
	 * 
	 * 迭代子模式涉及到以下几个角色：

　　●　　抽象迭代子(Iterator)角色：此抽象角色定义出遍历元素所需的接口。

　　●　　具体迭代子(ConcreteIterator)角色：此角色实现了Iterator接口，并保持迭代过程中的游标位置。

　　●　　聚集(Aggregate)角色：此抽象角色给出创建迭代子(Iterator)对象的接口。

　　●　　具体聚集(ConcreteAggregate)角色：实现了创建迭代子(Iterator)对象的接口，返回一个合适的具体迭代子实例。

　　●　　客户端(Client)角色：持有对聚集及其迭代子对象的引用，调用迭代子对象的迭代接口，也有可能通过迭代子操作聚集元素的增加和删除。

源代码

外禀迭代子的意义
　　一个常常会问的问题是：既然白箱聚集已经向外界提供了遍历方法，客户端已经可以自行进行迭代了，为什么还要应用迭代子模式，并创建一个迭代子对象进行迭代呢？

　　客户端当然可以自行进行迭代，不一定非得需要一个迭代子对象。但是，迭代子对象和迭代模式会将迭代过程抽象化，将作为迭代消费者的客户端与迭代负责人的迭代子责任分隔开，使得两者可以独立的演化。在聚集对象的种类发生变化，或者迭代的方法发生改变时，迭代子作为一个中介层可以吸收变化的因素，而避免修改客户端或者聚集本身。

　　此外，如果系统需要同时针对几个不同的聚集对象进行迭代，而这些聚集对象所提供的遍历方法有所不同时，使用迭代子模式和一个外界的迭代子对象是有意义的。具有同一迭代接口的不同迭代子对象处理具有不同遍历接口的聚集对象，使得系统可以使用一个统一的迭代接口进行所有的迭代。
	 * 
	 * @param args
	 */
	public static void main(String[] args) {
		
		
		Client client=new Client();
		client.operation();
		
	}

	private void operation() {

		Object [] objArray={"one","tow","three","four","five","six"};
		
		 //创建聚合对象
		
		Aggregate  agg=new ConcreteAggregate(objArray);
		
		//循环输出聚合对象中的值
		UIterator it=  agg.createIterator();
		while(!it.isDone()){
			System.out.println(it.currentItem());
			it.next();
		}
		
		
	}

}
